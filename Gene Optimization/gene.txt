import numpy as np

def f(x):
    return np.sum(x ** 2)

def initialize_population(population_size, num_genes):
    return np.random.uniform(low=-10, high=10, size=(population_size, num_genes))

def evaluate_fitness(population):
    return np.array([f(ind) for ind in population])

def selection(population, fitness, selection_size):
    selected_indices = np.argsort(fitness)[:selection_size]
    return population[selected_indices]

def crossover(parents, crossover_rate):
    offspring = []
    num_parents = parents.shape[0]
    for i in range(0, num_parents - 1, 2):
        parent1, parent2 = parents[i], parents[i + 1]
        if np.random.rand() < crossover_rate:
            crossover_point = np.random.randint(1, parents.shape[1])
            child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
            child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
        else:
            child1, child2 = parent1.copy(), parent2.copy()
        offspring.append(child1)
        offspring.append(child2)
    if num_parents % 2 == 1:
        offspring.append(parents[-1].copy())
    return np.array(offspring)

def mutation(offspring, mutation_rate):
    for i in range(offspring.shape[0]):
        for j in range(offspring.shape[1]):
            if np.random.rand() < mutation_rate:
                offspring[i, j] += np.random.normal()
    return offspring

def gene_expression(population):
    return population

def gene_expression_algorithm(population_size, num_genes, mutation_rate, crossover_rate, generations):
    population = initialize_population(population_size, num_genes)
    best_solution = None
    best_fitness = float('inf')

    for gen in range(generations):
        fitness = evaluate_fitness(population)
        if np.min(fitness) < best_fitness:
            best_solution = population[np.argmin(fitness)].copy()
            best_fitness = np.min(fitness)
        selected_population = selection(population, fitness, population_size // 2)
        offspring = crossover(selected_population, crossover_rate)
        mutated_offspring = mutation(offspring, mutation_rate)
        population = gene_expression(mutated_offspring)

    return best_solution, best_fitness

population_size = 50
num_genes = 10
mutation_rate = 0.01
crossover_rate = 0.7
generations = 100

best_solution, best_fitness = gene_expression_algorithm(
    population_size, num_genes, mutation_rate, crossover_rate, generations
)

print("Best Solution:", best_solution)
print("Best Fitness:", best_fitness)
